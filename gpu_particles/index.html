<!DOCTYPE html>
<html lang="en" dir="ltr">

<head>
  <meta charset="utf-8">
  <title>GPU Particles</title>
  <!-- MOBILE––––––––––––––––––––––– -->
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link href="https://fonts.googleapis.com/css2?family=Raleway:wght@300;400;600&display=swap" rel="stylesheet">
  <!-- CSS––––––––––––––––––––––– -->
  <link rel="stylesheet" href="../shared/css/normalize.css">
  <link rel="stylesheet" href="../shared/css/skeleton.css">
  <link rel="stylesheet" href="../shared/css/darkskelleton.css" media="(prefers-color-scheme: dark)">
  <link rel="stylesheet" href="../shared/css/style.css">
  <link rel="icon" type="image/png" href="/images/favicon.png">
</head>

<body>
  <div class="container" style="margin-top: 1em;">
    <a href="../">Back to Overview</a>
    <div class="row">
      <h1>GPU Particles</h1>
      <h2>Overview</h2>
      <p>Particle simulations - this time in parallel! I built this boilerplate for some upcoming GPU particle projects.
        Since the simulation is run as a parallel Shader on the GPU, it can handle millions of particles at once!
      </p>
    </div>

    <div class="row">
      <p id="webglWarning" style="display: none;">
        <b style="color: red;">Due to WebGL issues, the simulation might not work well on your device</b>
      </p>
      <canvas width="1024" height="1024" class="u-full-width" id="canvas"></canvas>
    </div>

    <div class="row">
      <h2>Design Decisions</h2>
      <p>
        Each particles is being represented as a pixel in the simulation texture. Since a pixel has 4 color channels,
        that means we can store 4 floating point numbers per particle. The first two are being used for the 2D
        position (x and y coordinates), the second two can be used for velocity. Since the particles in the physarum
        simulation I'm working on will be travelling at constant speeds, I opted to just store the direction and keep
        a free channel for additional data, like mass. At each time step we adjust the direction according to external
        forces, then calculate the velocity and position using a simple
        <a href="https://jurasic-park.de/ode/#euler">Euler integration step</a>. The updated colors get written
        to one of two framebuffers, that get swapped each frame (Ping-Pong Shader).
      </p>

      <figure>
        <img src="../shared/images/simTexture.png" class="u-max-full-width"
          alt="Data texture containing the particle information">
        <figcaption>Data texture containing the particle information. The colors of each represent position and velocity
          of the according particle.</figcaption>
      </figure>
      <h2>Drawing to the screen</h2>
      <p>
        Obviously we don't want a noisy image like in the figure above, so how do we draw the particles to the
        screen? That happens in the Vertex Shader. For each pixel of the simulation texture, we create a vertex,
        whose coordinates get read from the red and green channels of the according pixel. Using the handy
        <code>GL_POINTS</code> rendering mode, we can simply draw these vertecies to the screen as points! Let's see the
        result:
      </p>
      <figure>
        <img src="../shared/images/integerErrors.png" class="u-max-full-width"
          alt="Rounding errors from using 8bit integer textures">
        <figcaption>Initial results. What happened here?</figcaption>
      </figure>
      <p>What happened? The particles should be moving outwards in a straight line, but instead they are all collecting
        in the upper right corner! This error is caused by the numeric precision of the texture. By default, textures
        store color values as unsigned 8bit integers - that means we can only use integer values ranging 0 -
        256. Since we need a lot higher precision and range for the simulation, a differen data type is required. I
        chose 32bit floating point, which has to be enabled using <code>OES_texture_float</code> first.
        Let's see how it looks now:
      </p>
      <figure>
        <img src="../shared/images/particlesim.png" class="u-max-full-width"
          alt="Particle Simulation using a 512xx512 simulation texture">
        <figcaption>Screenshot of the working particle simulation.</figcaption>
      </figure>

      <h2>What next?</h2>
      <p>Now that we have a basic particle simulation we can build uppon, there are a lot of possibilities. Maybe I
        could add some interactivity, force fields or nice colors - but I think that'll have to wait. For now, this
        is a good boilerplate to build uppon, I'm sure it'll find use later. </p>
    </div>
  </div>

  <!-- Minimal Vertex Shader -->
  <script id="vs" type="x-shader/x-vertex">
    attribute vec4 a_position;
    
    void main() {
      gl_Position = a_position;
    }
  </script>


  <!-- inital particle attributes Shader -->
  <script type="x-shader/x-fragment" id="initShader">
    precision mediump float;
    #define M_PI 3.141592653589793
    
    uniform vec2 u_simResolution;
    uniform vec2 u_resolution;
      
    vec2 n2rand(vec2 uv) {
      return vec2(fract(sin(dot(uv.xy, vec2(12.9898, 78.233))) * 43758.5453),
        fract(sin(dot(uv.xy * 1.61803, vec2(12.9898, 78.233))) * 43758.5453));
    }

    void main() {
      vec2 uv =2.* gl_FragCoord.xy/u_resolution -1.;
      //initial positions are in a grid, initial orientation is given by the blue channel [0,2pi]
      float dir = n2rand(uv).x*2.*M_PI;
      dir = atan(uv.x, uv.y);

      gl_FragColor = vec4(uv, dir, 1.);
    }
  </script>

  <!-- Point Sprite Vertex Shader -->
  <script id="vs_points" type="x-shader/x-vertex">
    precision mediump float;

    attribute vec2 a_Index; // UV index of the sprite
    uniform vec2 u_simResolution;
    uniform vec2 u_resolution; // width/height of screen
    uniform sampler2D u_simTexture;

    void main() {
      vec4 simData = texture2D(u_simTexture, 2.*a_Index/u_simResolution-1.);
      vec2 pos = simData.xy;
      gl_Position = vec4(pos, 0.0, 1.0);
      gl_PointSize =1.0;
    }
  </script>

  <!-- Final Render Shader Shader -->
  <script type="x-shader/x-fragment" id="renderShader">
    precision mediump float;
    
    uniform vec2 u_simResolution;
    uniform vec2 u_resolution;
    uniform vec3 u_pColor;
      
    void main() {
      gl_FragColor = vec4(u_pColor, 1.);
    }
  </script>

  <!-- update positions and velocities Shader -->
  <script type="x-shader/x-fragment" id="simShader">
    precision mediump float;

    #define M_PI 3.141592653589793

    uniform float u_speed;
    uniform float u_time;
    uniform float u_rotationRate;
    uniform vec2 u_simResolution;
    uniform vec2 u_resolution;
    uniform sampler2D u_simTexture;
    uniform float u_dt;
    uniform vec2 u_forceField;
  
    uniform float D_a, D_b, f, k;
    
    void main() {
      vec4 simData = texture2D(u_simTexture, gl_FragCoord.xy/u_simResolution);
      vec2 pos = simData.xy;
      float dir = simData.z; 


      if (pos.x*pos.x+pos.y*pos.y>1.) {
        float centerDir = atan(-pos.y, -pos.x);
        float delta = mod(centerDir - dir + 3.*M_PI, 2.*M_PI) - M_PI;
        if(delta > 0.){
          dir +=  u_rotationRate *u_dt;
        }else{
          dir -=  u_rotationRate *u_dt;
        }
      }else if(u_forceField != vec2(0.)){
        float centerDir = atan(u_forceField.y-pos.y, u_forceField.x-pos.x);
        float delta = mod(centerDir - dir + 3.*M_PI, 2.*M_PI) - M_PI;
        if(delta > .7){
          dir +=  u_rotationRate *u_dt/4.;
        }else if(delta< -.7){
          dir -=  u_rotationRate *u_dt/4.;
        }
      }
      // dir = mod(dir, 2.* M_PI);
      vec2 vel = vec2(cos(dir), sin(dir)) * u_speed;

      gl_FragColor = vec4(pos + vel*u_dt, dir, simData.w);
    }
  </script>

  <script type="text/javascript" src="../shared/twgl.min.js"></script>
  <script type="text/javascript" src="script.js"></script>
</body>
<script>var cfla = document.createElement('script'); cfla.defer = true; cfla.src = 'https://static.cloudflareinsights.com/beacon.min.js'; cfla.setAttribute("data-cf-beacon", '{"token": "f9f51233f11041a194c4d5f4511d8282"}'); if (!localStorage.getItem("devmode")) document.body.appendChild(cfla)</script>

</html>