<!DOCTYPE html>
<html lang="en" dir="ltr">

<head>
  <meta charset="utf-8">
  <title>GPU Particles</title>
  <!-- MOBILE––––––––––––––––––––––– -->
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link href="https://fonts.googleapis.com/css2?family=Raleway:wght@300;400;600&display=swap" rel="stylesheet">
  <!-- CSS––––––––––––––––––––––– -->
  <link rel="stylesheet" href="../shared/css/normalize.css">
  <link rel="stylesheet" href="../shared/css/skeleton.css">
  <link rel="stylesheet" href="../shared/css/darkskelleton.css" media="(prefers-color-scheme: dark)">
  <link rel="stylesheet" href="../shared/css/style.css">
  <link rel="icon" type="image/png" href="/images/favicon.png">
</head>

<body>
  <div class="container" style="margin-top: 1em;">
    <a href="../">Back to Overview</a>
    <div class="row">
      <h1>GPU Particles</h1>
      <h2>Overview</h2>
      <p>Particle simulations - this time in parallel! Since the simulation is run as a shader on the GPU, it
        can handle millions of particles at once!
      </p>
    </div>

    <div class="row">
      <p id="webglWarning" style="display: none;">
        <b style="color: red;">Due to WebGL issues, the simulation might not work well on your device</b>
      </p>
      <canvas width="1024" height="1024" class="u-full-width" id="canvas"></canvas>
      <button onclick="reinit()">restart</button>
    </div>

    <div class="row">
      <h2>Design Decisions</h2>
      <p>
        Each particle is being represented as a pixel in a simulation texture. Because every pixel has 4 color channels,
        4 floating point numbers can be stored per particle. The first two represent the 2D position (x and y
        coordinate), the second two usually get used for velocity. Since the particles in this particular simulation
        will be travelling at constant speeds, I decided to only store the direction instead and keep a free channel for
        additional data, like mass. At each time step we use a fragment shader to update the simulation texture, by
        calculating the new velocity and position using a simple <a href="/ode/#euler">Euler
          integration step</a>. The updated colors are written to one of two framebuffers, that get swapped each frame
        (Ping-Pong Shader).
      </p>

      <figure>
        <img src="../shared/images/simTexture.png" class="u-max-full-width"
          alt="Data texture containing the particle information">
        <figcaption>Data texture containing the particle information. Each pixels color represents position and
          velocity of an according particle.</figcaption>
      </figure>
      <h2>Drawing to the screen</h2>
      <p>
        Obviously we don't want a noisy image like in the figure above, so how do we draw the particles to the
        screen? That happens in the Vertex Shader. For each pixel of the simulation texture, a vertex is created,
        whose coordinates get read from the red and green channels of the according pixel. Since the simulation is only
        2D, the z coordinate of all particles is set to 0. Using the handy <code>GL_POINTS</code> rendering mode, these
        vertecies can then be drawn to the screen as points!
      </p>
      <figure>
        <img src="../shared/images/integerErrors.png" class="u-max-full-width"
          alt="Rounding errors from using 8bit integer textures">
        <figcaption>Initial results. What happened here?</figcaption>
      </figure>
      <p>What happened? The particles should be moving outwards in a straight line, but instead they are all collecting
        in the upper right corner! This error is caused by the numeric precision of the texture. By default, textures
        store color values as unsigned 8bit integers - that means only 256 values ranging [0, 1] are available. That
        might be fine for the typical color data stored in textures, but a simulation requires both higher precision and
        range. I opted for 32bit floating point textures, which allow for arbitrary unclamped values with very high
        numeric precision.
      </p>
      <figure>
        <img src="../shared/images/particlesim.png" class="u-max-full-width"
          alt="Particle Simulation using a 512x512 simulation texture">
        <figcaption>Screenshot of the working particle simulation.</figcaption>
      </figure>
      <p>With the basic simulation up and running, many other concepts can be explored. One possibility would be to add
        force fields or interactions between particles. For example I'll be exploring agent based simulations of slime
        molds in <a href="../physarum/">this experiment</a> soon.</p>
    </div>
  </div>

  <!-- Minimal Vertex Shader -->
  <script id="vs" type="x-shader/x-vertex">
    attribute vec4 a_position;
    void main() {
      gl_Position = a_position;
    }
  </script>


  <!-- inital particle attributes Shader -->
  <script type="x-shader/x-fragment" id="initShader">
    precision mediump float;
    #define M_PI 3.141592653589793
    
    uniform vec2 u_simResolution;
    uniform vec2 u_resolution;
    uniform int u_mode;
      
    vec2 n2rand(vec2 uv) {
      return vec2(fract(sin(dot(uv.xy, vec2(12.9898, 78.233))) * 43758.5453),
        fract(sin(dot(uv.xy * 1.61803, vec2(12.9898, 78.233))) * 43758.5453));
    }

    void main() {
      vec2 uv =2.* gl_FragCoord.xy/u_resolution -1.;
      //initial positions are in a grid, initial orientation is given by the blue channel [0,2pi]
      float dir;
      //for some reason switch wasn't working
      if(u_mode == 1){
        dir = atan(uv.x, uv.y);
      }else if(u_mode == 2){
        dir = cos(3.*uv.x)*sin(3.*uv.y)*2.*M_PI;
      }else if(u_mode == 3){
        dir = acos(uv.x/uv.y);
      }else if(u_mode == 4){
        dir = uv.x/uv.y;
      }else if(u_mode == 5){
        dir = atan(uv.y,uv.x);
      }else{
        dir = n2rand(uv).x*2.*M_PI;
      }

      gl_FragColor = vec4(uv, dir, 1.);
    }
  </script>

  <!-- Point Sprite Vertex Shader -->
  <script id="vs_points" type="x-shader/x-vertex">
    precision mediump float;

    attribute vec2 a_Index; // UV index of the sprite
    uniform vec2 u_simResolution;
    uniform vec2 u_resolution; // width/height of screen
    uniform sampler2D u_simTexture;

    void main() {
      vec4 simData = texture2D(u_simTexture, 2.*a_Index/u_simResolution-1.);
      vec2 pos = simData.xy;
      gl_Position = vec4(pos, .0, 1.);
      gl_PointSize =1.0;
    }
  </script>

  <!-- Final Render Shader Shader -->
  <script type="x-shader/x-fragment" id="renderShader">
    precision mediump float;
    
    uniform vec2 u_simResolution;
    uniform vec2 u_resolution;
    uniform vec3 u_pColor;
      
    void main() {
      gl_FragColor = vec4(u_pColor, 1.);
    }
  </script>

  <!-- update positions and velocities Shader -->
  <script type="x-shader/x-fragment" id="simShader">
    precision mediump float;

    #define M_PI 3.141592653589793

    uniform float u_speed;
    uniform float u_time;
    uniform float u_rotationRate;
    uniform vec2 u_simResolution;
    uniform vec2 u_resolution;
    uniform sampler2D u_simTexture;
    uniform float u_dt;
    uniform vec2 u_forceField;
  
    uniform float D_a, D_b, f, k;
    
    void main() {
      vec4 simData = texture2D(u_simTexture, gl_FragCoord.xy/u_simResolution);
      vec2 pos = simData.xy;
      float dir = simData.z; 


      if (pos.x*pos.x+pos.y*pos.y>1.) {
        float centerDir = atan(-pos.y, -pos.x);
        float delta = mod(centerDir - dir + 3.*M_PI, 2.*M_PI) - M_PI;
        if(delta > 0.){
          dir +=  u_rotationRate *u_dt;
        }else{
          dir -=  u_rotationRate *u_dt;
        }
      }else if(u_forceField != vec2(0.)){
        float centerDir = atan(u_forceField.y-pos.y, u_forceField.x-pos.x);
        float delta = mod(centerDir - dir + 3.*M_PI, 2.*M_PI) - M_PI;
        if(delta > .7){
          dir +=  u_rotationRate *u_dt/4.;
        }else if(delta< -.7){
          dir -=  u_rotationRate *u_dt/4.;
        }
      }
      // dir = mod(dir, 2.* M_PI);
      vec2 vel = vec2(cos(dir), sin(dir)) * u_speed;

      gl_FragColor = vec4(pos + vel*u_dt, dir, simData.w);
    }
  </script>

  <script type="text/javascript" src="../shared/twgl.min.js"></script>
  <script type="text/javascript" src="script.js"></script>
</body>
<script>var cfla = document.createElement('script'); cfla.defer = true; cfla.src = 'https://static.cloudflareinsights.com/beacon.min.js'; cfla.setAttribute("data-cf-beacon", '{"token": "f9f51233f11041a194c4d5f4511d8282"}'); if (!localStorage.getItem("devmode")) document.body.appendChild(cfla)</script>

</html>